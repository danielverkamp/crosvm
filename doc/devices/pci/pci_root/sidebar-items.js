initSidebarItems({"constant":[["PCIE_XBAR_BASE_ADDR",""],["PCI_DEVICE_ID_INTEL_82441",""],["PCI_RESET_CPU_BIT",""]],"enum":[["PciRootCommand",""]],"struct":[["PciConfigIo","Emulates PCI configuration access mechanism #1 (I/O ports 0xcf8 and 0xcfc)."],["PciConfigMmio","Emulates PCI memory-mapped configuration access mechanism."],["PciRoot","Emulates the PCI Root bridge."],["PciRootConfiguration",""],["PciVirtualConfigMmio","Inspired by PCI configuration space, CrosVM provides 2048 dword virtual registers (8KiB in total) for each PCI device. The guest can use these registers to exchange device-specific information with CrosVM. The first 4kB is trapped by crosvm and crosm supply these register’s emulation. The second 4KB is mapped into guest directly as shared memory, so when guest access this 4KB, vm exit doesn’t happen. All these virtual registers from all PCI devices locate in a contiguous memory region. The base address of this memory region is provided by an IntObj named VCFG in the ACPI DSDT. Bit 12 is used to select the first trapped page or the second directly mapped page The offset of each register is calculated in the same way as PCIe ECAM; i.e. offset = (bus << 21) | (device << 16) | (function << 13) | (page_select << 12) | (register_index << 2)"]]});
initSidebarItems({"enum":[["Ac97Backend","AC97 audio device emulation. Provides the PCI interface for the internal Ac97 emulation. Internally the `Ac97BusMaster` and `Ac97Mixer` structs are used to emulated the bus master and mixer registers respectively. `Ac97BusMaster` handles moving smaples between guest memory and the audio backend."],["BusError",""],["BusType",""],["CoIommuUnpinPolicy","Holds the coiommu unpin policy"],["CrosvmDeviceId",""],["HostHotPlugKey","The key to identify hotplug device from host view. like host sysfs path for vfio pci device, host disk file path for virtio block device"],["IommuDevType",""],["ParseIommuDevTypeResult",""],["PciAddressError","PCI address parsing and conversion errors."],["PciClassCode","Classes of PCI nodes."],["PciDeviceError",""],["PciInterruptPin","PCI has four interrupt pins A->D."],["PciRootCommand",""],["PitError",""],["ProxyError","Errors for proxy devices."],["PvPanicCode",""],["UnpinResponse",""]],"macro":[["register",""],["register_array",""],["static_register","Macro helps to build a static register."],["usb_debug",""]],"mod":[["acpi",""],["bat",""],["bus","Handles routing to devices in an address space."],["bus_stats",""],["cmos",""],["debugcon",""],["direct_io",""],["direct_irq",""],["i8042",""],["irq_event",""],["irqchip",""],["pci","Implements pci devices and busses."],["pflash","Programmable flash device that supports the minimum interface that OVMF requires. This is purpose-built to allow OVMF to store UEFI variables in the same way that it stores them on QEMU."],["pit",""],["pl030",""],["platform","Implements platform devices and busses."],["proxy","Runs hardware devices in child processes."],["register_space",""],["serial",""],["serial_device",""],["software_tpm","Software TPM backend using the TPM2 simulator from the `tpm2` crate."],["sys",""],["tsc","Handles operations using platform Time Stamp Counter (TSC)."],["usb",""],["utils",""],["vfio",""],["vfio_wrapper","Wraps VfioContainer for virtio-iommu implementation"],["virtio","Implements virtio devices, queues, and transport mechanisms."],["vmwdt","vmwdt is a virtual watchdog memory mapped device which detects stalls on the vCPUs and resets the guest when no ‘pet’ events are received. https://docs.google.com/document/d/1DYmk2roxlwHZsOfcJi8xDMdWOHAmomvs2SDh7KPud3Y/edit?usp=sharing&resourcekey=0-oSNabc-t040a1q0K4cyI8Q"]],"struct":[["Ac97Dev",""],["Ac97Parameters","Holds the parameters for a AC97 device"],["BarRange","Pci Bar Range information"],["Bus","A device container for routing reads and writes over some address space."],["BusAccessInfo","Information about how a device was accessed."],["BusRange","Holds a base and length representing the address space occupied by a `BusDevice`."],["BusStatistics","Statistics about how a bus has been accessed."],["Cmos","A CMOS/RTC device commonly seen on x86 I/O port 0x70/0x71."],["CoIommuDev",""],["CoIommuParameters","Holds the parameters for a coiommu device"],["Debugcon",""],["I8042Device","A i8042 PS/2 controller that emulates just enough to shutdown the machine."],["IrqEdgeEvent","A structure suitable for implementing edge triggered interrupts in device backends."],["IrqLevelEvent","A structure suitable for implementing level triggered interrupts in device backends."],["PciAddress","PCI Device Address, AKA Bus:Device.Function"],["PciBridge",""],["PciBus","Pci Bus information"],["PciConfigIo","Emulates PCI configuration access mechanism #1 (I/O ports 0xcf8 and 0xcfc)."],["PciConfigMmio","Emulates PCI memory-mapped configuration access mechanism."],["PciRoot","Emulates the PCI Root bridge."],["PciVirtualConfigMmio","Inspired by PCI configuration space, CrosVM provides 2048 dword virtual registers (8KiB in total) for each PCI device. The guest can use these registers to exchange device-specific information with CrosVM. The first 4kB is trapped by crosvm and crosm supply these register’s emulation. The second 4KB is mapped into guest directly as shared memory, so when guest access this 4KB, vm exit doesn’t happen. All these virtual registers from all PCI devices locate in a contiguous memory region. The base address of this memory region is provided by an IntObj named VCFG in the ACPI DSDT. Bit 12 is used to select the first trapped page or the second directly mapped page The offset of each register is calculated in the same way as PCIe ECAM; i.e. offset = (bus << 21) | (device << 16) | (function << 13) | (page_select << 12) | (register_index << 2)"],["PcieDownstreamPort",""],["PcieHostPort","Pcie root port device has a corresponding host pcie root port."],["PcieRootPort",""],["PcieUpstreamPort",""],["Pflash",""],["PflashParameters",""],["Pit",""],["ProxyDevice","Wraps an inner `BusDevice` that is run inside a child process via fork."],["PvPanicPciDevice",""],["Serial","Emulates serial COM ports commonly seen on x86 I/O ports 0x3f8/0x2f8/0x3e8/0x2e8."],["SoftwareTpm",""],["StubPciDevice",""],["StubPciParameters",""],["UnpinRequest",""],["VfioPciDevice","Implements the Vfio Pci device, then a pci device is added into vm"],["VfioPlatformDevice",""],["VirtioMmioDevice","Implements the MMIO transport for virtio devices."],["VirtioPciDevice","Implements the PCI transport for virtio devices."]],"trait":[["BusDevice","Trait for devices that respond to reads or writes in an arbitrary address space."],["BusDeviceObj","Trait for generic device abstraction, that is, all devices that reside on BusDevice and want to be converted back to its original type. Each new foo device must provide as_foo_device() + as_foo_device_mut() + into_foo_device(), default impl methods return None."],["BusDeviceSync",""],["BusResumeDevice",""],["HotPlugBus","Trait for devices that notify hotplug event into guest"],["PciDevice",""],["SerialDevice","Abstraction over serial-like devices that can be created given an event and optional input and output streams."]]});
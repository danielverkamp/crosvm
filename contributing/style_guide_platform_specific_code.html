<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Style Guide for Platform-Specific Code - Book of crosvm</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../building_crosvm.html"><strong aria-hidden="true">2.</strong> Building Crosvm</a></li><li class="chapter-item expanded "><a href="../running_crosvm/index.html"><strong aria-hidden="true">3.</strong> Running Crosvm</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../running_crosvm/example_usage.html"><strong aria-hidden="true">3.1.</strong> Example Usage</a></li><li class="chapter-item expanded "><a href="../running_crosvm/advanced_usage.html"><strong aria-hidden="true">3.2.</strong> Advanced Usage</a></li><li class="chapter-item expanded "><a href="../running_crosvm/custom_kernel_rootfs.html"><strong aria-hidden="true">3.3.</strong> Custom Kernel / Rootfs</a></li><li class="chapter-item expanded "><a href="../running_crosvm/requirements.html"><strong aria-hidden="true">3.4.</strong> System Requirements</a></li><li class="chapter-item expanded "><a href="../running_crosvm/features.html"><strong aria-hidden="true">3.5.</strong> Features</a></li><li class="chapter-item expanded "><a href="../running_crosvm/programmatic_interaction.html"><strong aria-hidden="true">3.6.</strong> Programmatic Interaction</a></li></ol></li><li class="chapter-item expanded "><a href="../devices/index.html"><strong aria-hidden="true">4.</strong> Devices</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../devices/block.html"><strong aria-hidden="true">4.1.</strong> Block</a></li><li class="chapter-item expanded "><a href="../devices/net.html"><strong aria-hidden="true">4.2.</strong> Network</a></li><li class="chapter-item expanded "><a href="../devices/balloon.html"><strong aria-hidden="true">4.3.</strong> Balloon</a></li><li class="chapter-item expanded "><a href="../devices/pmem.html"><strong aria-hidden="true">4.4.</strong> Pmem</a></li><li class="chapter-item expanded "><a href="../devices/wayland.html"><strong aria-hidden="true">4.5.</strong> Wayland</a></li><li class="chapter-item expanded "><a href="../devices/video.html"><strong aria-hidden="true">4.6.</strong> Video (experimental)</a></li><li class="chapter-item expanded "><a href="../devices/vhost_user.html"><strong aria-hidden="true">4.7.</strong> Vhost-user</a></li><li class="chapter-item expanded "><a href="../devices/vvu.html"><strong aria-hidden="true">4.8.</strong> VirtIO Vhost-user (VVU)</a></li></ol></li><li class="chapter-item expanded "><a href="../integration/index.html"><strong aria-hidden="true">5.</strong> Integration</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../integration/chromeos.html"><strong aria-hidden="true">5.1.</strong> ChromeOS</a></li></ol></li><li class="chapter-item expanded "><a href="../architecture.html"><strong aria-hidden="true">6.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="../contributing/index.html"><strong aria-hidden="true">7.</strong> Contributing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../contributing/style_guide_platform_specific_code.html" class="active"><strong aria-hidden="true">7.1.</strong> Style Guide for Platform-Specific Code</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="../onboarding.html"><strong aria-hidden="true">8.</strong> Onboarding Resources</a></li><li class="chapter-item expanded "><a href="../appendix/index.html"><strong aria-hidden="true">9.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../appendix/sandboxing.html"><strong aria-hidden="true">9.1.</strong> Sandboxing</a></li><li class="chapter-item expanded "><a href="../appendix/seccomp.html"><strong aria-hidden="true">9.2.</strong> Seccomp</a></li><li class="chapter-item expanded "><a href="../appendix/memory_layout.html"><strong aria-hidden="true">9.3.</strong> Memory Layout</a></li><li class="chapter-item expanded "><a href="../appendix/minijail.html"><strong aria-hidden="true">9.4.</strong> Minijail</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="../package_documentation.html">Package Documentation</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Book of crosvm</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="style-guide-for-platform-specific-code"><a class="header" href="#style-guide-for-platform-specific-code">Style guide for platform specific code</a></h1>
<h2 id="code-organization"><a class="header" href="#code-organization">Code organization</a></h2>
<p>The crosvm code can heavily interleave platform specific code into platform agnostic code using
<code>#[cfg(target_os = &quot;&quot;)]</code>. This is difficult to maintain as</p>
<ul>
<li>It reduces readability.</li>
<li>Difficult to write/maintain unit tests.</li>
<li>Difficult to maintain downstream, proprietary code</li>
</ul>
<p>To address the above mentioned issue, the style guide provides a way to standardize platform
specific code layout.</p>
<p>Consider a following example where we have platform independent code, <code>PrintInner</code>, which is used by
platform specific code, <code>WinPrinter</code> and <code>UnixPrinter</code> to tweak the behavior according to the
underlying platform. The users of this module, <code>sys</code>, get to use an aliased struct called <code>Printer</code>
which exports similar interfaces on both the platforms.</p>
<p>In this scheme <code>print.rs</code> contains platform agnostic logic, structures and traits. Different
platforms, in <code>unix.rs</code> and <code>windows.rs</code>, implement traits defined in <code>print.rs</code>. Finally <code>sys.rs</code>
exports interfaces implemented by platform specific code.</p>
<p>In a more complex library, we may need another layer, <code>print.rs</code>, that uses traits and structures
exported by platform specific code, <code>unix/print.rs</code> and <code>windows/print.rs</code>, and adds some more
common logic to it. Following example illustrates the scheme discussed above. Here,
<code>Printer.print()</code> is supposed to print a value of <code>u32</code> and print the target os name.</p>
<p>The files that contain platform specific code <strong>only</strong> should live in a directory named <code>sys/</code> and
those files should be conditionally imported in <code>sys.rs</code> file. In such a setup, the directory
structure would look like,</p>
<pre><code class="language-bash">$  tree
.
├── print.rs
├── sys
│   ├── unix
│   │   └── print.rs
│   ├── unix.rs
│   ├── windows
│   │   └── print.rs
│   └── windows.rs
└── sys.rs
</code></pre>
<p>File: <code>print.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct PrintInner {
    pub value: u32,
}

impl PrintInner {
    pub fn new(value: u32) -&gt; Self {
        Self { value }
    }

    pub fn print(&amp;self) {
        print!(&quot;My value:{} &quot;, self.value);
    }
}

// This is useful if you want to
// * Enforce interface consistency or
// * Have more than one compiled-in struct to provide the same api.
//   Say a generic gpu driver and high performance proprietary driver
//   to coexist in the same namespace.
pub trait Print {
    fn print(&amp;self);
}
<span class="boring">}
</span></code></pre></pre>
<p>File: <code>sys/windows/print.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::print::{Print, PrintInner};

pub struct WinPrinter {
    inner: PrintInner,
}

impl WinPrinter {
    pub fn new(value: u32) -&gt; Self {
        Self {
            inner: PrintInner::new(value),
        }
    }
}

impl Print for WinPrinter {
    fn print(&amp;self) {
        self.inner.print();
        println!(&quot;from win&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>File: <code>sys/unix/print.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::print::{Print, PrintInner};

pub struct UnixPrinter {
    inner: PrintInner,
}

impl UnixPrinter {
    pub fn new(value: u32) -&gt; Self {
        Self {
            inner: PrintInner::new(value),
        }
    }
}

impl Print for UnixPrinter {
    fn print(&amp;self) {
        self.inner.print();
        println!(&quot;from unix&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>File: <code>sys.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cfg_if::cfg_if! {
    if #[cfg(unix)] {
        mod unix;
        pub use platform_print::UnixPrinter as Printer;
    } else if #[cfg(windows)] {
        mod windows;
        pub use platform_print::WinPrinter as Printer;
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="imports"><a class="header" href="#imports">Imports</a></h2>
<p>When conditionally importing and using modules, use <code>cfg(unix)</code> and <code>cfg(windows)</code> for describing
the platform. Order imports such that common comes first followed by unix and windows dependencies.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// All other imports

#[cfg(unix)]
use {
  std::x::y,
  base::a::b::{Foo, Bar},
  etc::Etc,
};

#[cfg(windows)]
use {
  std::d::b,
  base::f::{Foo, Bar},
  etc::{WinEtc as Etc},
};
<span class="boring">}
</span></code></pre></pre>
<h2 id="structure"><a class="header" href="#structure">Structure</a></h2>
<p>It is OK to have a few platform specific fields inlined with cfgs. When inlining</p>
<ul>
<li>Ensure that all the fields of a particular platform are next to each other.</li>
<li>Organize common fields first and then platform specific fields ordered by the target os name i.e.
&quot;unix&quot; first and &quot;windows&quot; later.</li>
</ul>
<p>If the structure has a large set of fields that are platform specific, it is more readable to split
it into different platform specific structures and have their implementations separate. If
necessary, consider defining a crate in platform independent and have the platform specific files
implement parts of those traits.</p>
<h2 id="enum"><a class="header" href="#enum">Enum</a></h2>
<p>When enums need to have platform specific variants</p>
<ul>
<li>Create a new platform specific enum and move all platform specific variants under the new enum</li>
<li>Introduce a new variant, which takes a platform specific enum as member, to platform independent
enum.</li>
</ul>
<h3 id="do"><a class="header" href="#do">Do</a></h3>
<p>File: <code>sys/unix/base.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum MyEnumSys {
  Unix1,
}

fn handle_my_enum_impl(e: MyEnumSys) {
  match e {
    Unix1 =&gt; {..},
  };
}
<span class="boring">}
</span></code></pre></pre>
<p>File: <code>sys/windows/base.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum MyEnumSys {
  Windows1,
}

fn handle_my_enum_impl(e: MyEnumSys) {
  match e {
    Windows1 =&gt; {..},
  };
}
<span class="boring">}
</span></code></pre></pre>
<p>File: <code>base.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use sys::MyEnumSys;
enum MyEnum {
  Common1,
  Common2,
  SysVariants(MyEnumSys),
}

fn handle_my_enum(e: MyEnum) {
  match e {
    Common1 =&gt; {..},
    Common2 =&gt; {..},
    SysVariants(v) =&gt; handle_my_enum_impl(v),
  };
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="dont"><a class="header" href="#dont">Don't</a></h3>
<p>File: <code>base.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum MyEnum {
  Common1,
  Common2,
  #[cfg(target_os = &quot;windows&quot;)]
  Windows1, // We shouldn't have platform-specific variants in a platform-independent enum.
  #[cfg(target_os = &quot;unix&quot;)]
  Unix1, // We shouldn't have platform-specific variants in a platform-independent enum.
}

fn handle_my_enum(e: MyEnum) {
  match e {
    Common1 =&gt; {..},
    Common2 =&gt; {..},
    #[cfg(target_os = &quot;windows&quot;)]
    Windows1 =&gt; {..}, // We shouldn't have platform-specific match arms in a platform-independent code.
    #[cfg(target_os = &quot;unix&quot;)]
    Unix1 =&gt; {..}, // We shouldn't have platform-specific match arms in a platform-independent code.
  };
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="code-blocks-and-functions"><a class="header" href="#code-blocks-and-functions">Code blocks and functions</a></h2>
<p>If a code block or a function has little platform independent code and the bulk of the code is
platform specific then carve out platform specific code into a function. If the carved out function
does most of what the original function was doing and there is no better name for the new function
then the new function can be named by appending <code>_impl</code> to the functions name.</p>
<h3 id="do-1"><a class="header" href="#do-1">Do</a></h3>
<p>File: <code>base.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn my_func() {
  print!(&quot;Hello &quot;);
  my_func_impl();
}
<span class="boring">}
</span></code></pre></pre>
<p>File: <code>sys/unix/base.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn my_func_impl() {
  println!(&quot;unix&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>File: <code>sys/windows/base.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn my_func_impl() {
  println!(&quot;windows&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="dont-1"><a class="header" href="#dont-1">Don't</a></h3>
<p>File: <code>base.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn my_func() {
  print!(&quot;Hello &quot;);

  #[cfg(target_os = &quot;unix&quot;)] {
    println!(&quot;unix&quot;); // We shouldn't have platform-specific code in a platform-independent code block.
  }

  #[cfg(target_os = &quot;windows&quot;)] {
    println!(&quot;windows&quot;); // We shouldn't have platform-specific code in a platform-independent code block.
  }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="match"><a class="header" href="#match">match</a></h2>
<p>With an exception to matching enums, see <a href="#enum">enum</a>, matching for platform specific values can be
done in the wildcard patter(<code>_</code>) arm of the match statement.</p>
<h3 id="do-2"><a class="header" href="#do-2">Do</a></h3>
<p>File: <code>parse.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn parse_args(arg: &amp;str) -&gt; Result&lt;()&gt;{
  match arg {
    &quot;path&quot; =&gt; {
      &lt;multiple lines of logic&gt;;
      Ok(())
    },
    _ =&gt; parse_args_impl(arg),
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>File: <code>sys/unix/parse.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn parse_args_impl(arg: &amp;str) -&gt; Result&lt;()&gt;{
  match arg {
    &quot;fd&quot; =&gt; {
      &lt;multiple lines of logic&gt;;
      Ok(())
    },
    _ =&gt; Err(ParseError),
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>File: <code>sys/windows/parse.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn parse_args_impl(arg: &amp;str) -&gt; Result&lt;()&gt;{
  match arg {
    &quot;handle&quot; =&gt; {
      &lt;multiple lines of logic&gt;;
      Ok(())
    },
    _ =&gt; Err(ParseError),
  }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="dont-2"><a class="header" href="#dont-2">Don't</a></h3>
<p>File: <code>parse.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn parse_args(arg: &amp;str) -&gt; Result&lt;()&gt;{
  match arg {
    &quot;path&quot; =&gt; Ok(()),
    #[cfg(target_os = &quot;unix&quot;)]
    &quot;fd&quot; =&gt; { // We shouldn't have platform-specific match arms in a platform-independent code.
      &lt;multiple lines of logic&gt;;
      Ok(())
    },
    #[cfg(target_os = &quot;windows&quot;)]
    &quot;handle&quot; =&gt; { // We shouldn't have platform-specific match arms in a platform-independent code.
      &lt;multiple lines of logic&gt;;
      Ok(())
    },
    _ =&gt; Err(ParseError),
  }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="errors"><a class="header" href="#errors">Errors</a></h2>
<p>Inlining all platform specific error values is ok. This is an exception to the <a href="#enum">enum</a> to keep
error handling simple. Organize platform independent errors first and then platform specific errors
ordered by the target os name i.e. &quot;unix&quot; first and &quot;windows&quot; later.</p>
<h2 id="platform-specific-symbols"><a class="header" href="#platform-specific-symbols">Platform specific symbols</a></h2>
<p>If a platform exports symbols that are specific to the platform only and are not exported by all
other platforms then those symbols should be made public through a namespace that reflects the name
of the platform.</p>
<p>File: <code>sys.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cfg_if::cfg_if! {
    if #[cfg(unix)] {
        pub mod unix;
        use unix as platform;
    } else if #[cfg(windows)] {
        pub mod windows;
        use windows as platform;
    }
}

pub use platform::print;
<span class="boring">}
</span></code></pre></pre>
<p>File: <code>unix.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print() {
  println!(&quot;Hello unix&quot;);
}

fn print_u8(val: u8) {
  println!(&quot;Unix u8:{}&quot;, val);

}
<span class="boring">}
</span></code></pre></pre>
<p>File: <code>windows.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print() {
  println!(&quot;Hello windows&quot;);
}

fn print_u16(val: u16) {
  println!(&quot;Windows u16:{}&quot;, val);

}
<span class="boring">}
</span></code></pre></pre>
<p>The user of the library, say mylib, now has to do something like below which makes it explicit that
the functions <code>print_u8</code> and <code>print_u16</code> are platform specific.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use mylib::sys::print;

fn my_print() {
  print();

  #[cfg(unix)]
  mylib::sys::unix::print_u8(1);

  #[cfg(windows)]
  mylib::sys::windows::print_u16(1);
}

<span class="boring">}
</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../contributing/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../onboarding.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../contributing/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../onboarding.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../mermaid.min.js"></script>
        <script type="text/javascript" src="../mermaid-init.js"></script>
    </body>
</html>
